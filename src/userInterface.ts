import { AlgoVisualizer } from './algoVisualizer'
import { Timeline } from "./lib/anime.esm"

//TODO disable input when animation is playing
/**
 *
 * Implements the functionality of buttons and sliders for interaction with a
 * b+ tree visualization.
 * @dependency For this class to function there must be a specific html
 * structure in the dom. This structure is defined in index.html.
 */
export const userInterface = () => {
    // ** global constants section ** //
    const algoVisualizer = new AlgoVisualizer(4)
    const animationToggle = <HTMLInputElement>document.querySelector('#animation-toggle')
    const speedControlCheckboxes: NodeListOf<HTMLInputElement> = document.
        querySelectorAll('input[type="checkbox"][name="speed"]');
    // ** end global constants section ** // 
    // ** begin global variables section ** //
    let currentAnimation: Timeline | null = null
    let currentAnimationOriginalDuration = 0
    // for animation, 1 is normal speed, 2 is double speed ex.
    let speedModifier = 1
    // ** end global variables section ** //

    const insertButton = document.querySelector('#insert-button');
    insertButton?.addEventListener('click', async () => {
        const numberInput = <HTMLInputElement>document.querySelector('#number-input')
        if (numberInput?.value) {
            const numbers = numberInput.value.split(',').map(Number);
            await numbers.reduce(async (previousPromise, num) => {
                await previousPromise;
                // We need to wait here because if the undoable insert function is called again
                // right after the last animation completed the animation generated by the next
                // call will be wrong. I don't know why TODO
                currentAnimation = algoVisualizer.undoableInsert(num);
                if (currentAnimation === null) return
                //@ts-expect-error
                currentAnimationOriginalDuration = generatedTimeline.duration
                currentAnimation.stretch(currentAnimationOriginalDuration / speedModifier).play()
                await currentAnimation.then(() => true)
                await new Promise(resolve => setTimeout(resolve, 10)); // Wait for 10 milliseconds
            }, Promise.resolve());
        }
        updateTimelineInput()
    });

    const deleteButton = document.querySelector('#delete-button');
    deleteButton?.addEventListener('click', async () => {
        const numberInput = <HTMLInputElement>document.querySelector('#number-input')
        if (numberInput?.value) {
            const numbers = numberInput.value.split(',').map(Number);
            await numbers.reduce(async (previousPromise, num) => {
                await previousPromise;
                const currentAnimation = algoVisualizer.undoableDelete(num);
                if(currentAnimation === null) return
                await currentAnimation.then(() => true)
                await new Promise(resolve => setTimeout(resolve, 10)); // Wait for 10 milliseconds
            }, Promise.resolve());
        }
        updateTimelineInput()
    });

    const playButton = document.querySelector('#play-button')
    playButton?.addEventListener('click', () => {
        if (currentAnimation) {
            currentAnimation.play()
        } else {
            console.log('no animation to play')
        }
    })

    const backButton = document.querySelector('#back-button')
    backButton?.addEventListener('click', () => {
        const stepBackReturn = algoVisualizer.algoStepHistory.stepBackwards()
        if(stepBackReturn === null) return
        currentAnimation = stepBackReturn
    })

    const forwardButton = document.querySelector('#forward-button')
    forwardButton?.addEventListener('click', () => {
        const stepForwardReturn = algoVisualizer.algoStepHistory.stepForwards()
        if(stepForwardReturn === null) return
        currentAnimation = stepForwardReturn
    })

    const timelineInput = <HTMLInputElement>document.querySelector('#timeline-input')
    timelineInput?.addEventListener('input', () => {
        // console.debug('input event fired')
        if (currentAnimation) {
            currentAnimation.seek(timelineInput.valueAsNumber * currentAnimation.duration)
        }
    })

    // TODO refine this behavior. ex. make is so deselecting a checkbox doesn't start animation
    // again for example when the animation already finished.
    // Speed checkboxes listener
    speedControlCheckboxes.forEach((checkbox) => {
        checkbox.addEventListener('mousedown', function (this: HTMLInputElement) {
            const currentAnimeProgress = algoVisualizer.currentAnimation.progress
            // If the checkbox button is already checked
            if (this.checked == false) {
                // Make the checkboxes mutually exclusive
                speedControlCheckboxes.forEach((checkbox) => {
                    checkbox.checked = false;
                })
                speedModifier = Number(this.value)
                // Make it so that when a new speed modifier is selected and an animation is
                // currently playing the animation speeds up at the current location in the animation.
                // So that it looks seamless to the user.
                algoVisualizer.currentAnimation.stretch(currentAnimationOriginalDuration / speedModifier)
                // if we don't restart here there is one frame where the animation appears to be at a
                // different location than it should be. I don't know why this is.
                algoVisualizer.currentAnimation.restart()
                if (currentAnimeProgress == 1) {
                    // for some reason setting progress to 1 doesn't seem to 
                    // do anything. Therefore in order for the animation to
                    // appear as though it is at the end we set the progress
                    // to 0.99999. A number very close to 1
                    algoVisualizer.currentAnimation.progress = 0.99999
                } else {
                    algoVisualizer.currentAnimation.progress = currentAnimeProgress
                }
            } else {
                speedModifier = 1
                algoVisualizer.currentAnimation.stretch(currentAnimationOriginalDuration)
                // see comments above for clarification on this line
                algoVisualizer.currentAnimation.restart()
                if (currentAnimeProgress == 1) {
                    // see comments above for clarification on this line
                    algoVisualizer.currentAnimation.progress = 0.99999
                } else {
                    algoVisualizer.currentAnimation.progress = currentAnimeProgress
                }
            }
        });
    });

    animationToggle?.addEventListener('input', setAnimationToggle)


    /**
     *
     * Manipulates the range input dom element for controlling animations so
     * that the current animejs animation can be controlled correctly. Should be
     * called every time that the currentAnimation global is reassigned.
     * @returns 1 if successful and 0 if not
     */
    const updateTimelineInput = () => {
        console.debug('update timeline input')

        // TODO find solution for the fact that the children attribute is not
        // apart of the type.
        //timelineInput?.setAttribute('max', String(currentAnimation?.children.length))
        return 1
    }
}