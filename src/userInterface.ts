import { AlgoVisualizer } from './algoVisualizer'

/**
 *
 * Implements the functionality of buttons and sliders for interaction with a b+ tree visualization.
 * @dependency For this class to function there must be a specific html
 * structure in the dom. This structure is defined in index.html.
 */
export const userInterface = () => {
    console.debug("init user interface")
    const algoVisualizer = new AlgoVisualizer(4)
    let currentAnimationOriginalDuration = 0
    const checkboxes: NodeListOf<HTMLInputElement> = document.querySelectorAll('input[type="checkbox"][name="speed"]');
    // for animation, 1 is normal speed, 2 is double speed ex.
    let speedModifier = 1

    const animationToggle = <HTMLInputElement>document.querySelector('#animation-toggle')
    const setAnimationToggle = () => {
        console.debug('animation toggle event fired')
        if (!algoVisualizer) return

        if (animationToggle?.checked) {
            algoVisualizer.animationDuration = 0.2
        } else {
            algoVisualizer.animationDuration = 1000
        }
    }

    const insertButton = document.querySelector('#insert-button');
    //TODO make is so that this can't run to instances of the async callback at once.
    insertButton?.addEventListener('click', async () => {
        const numberInput = <HTMLInputElement>document.querySelector('#number-input')

        // Make sure that the right animation duration is used
        setAnimationToggle()

        if (numberInput?.value) {
            const numbers = numberInput.value.split(',').map(Number);
            await numbers.reduce(async (previousPromise, num) => {
                await previousPromise;
                // We need to wait here because if the undoable insert function is called again
                // right after the last animation completed the animation generated by the next
                // call will be wrong. I don't know why TODO
                const generatedTimeline = algoVisualizer.undoableInsert(num);
                if(generatedTimeline === null) return
                //@ts-expect-error
                currentAnimationOriginalDuration = generatedTimeline.duration
                generatedTimeline.stretch(currentAnimationOriginalDuration / speedModifier).play()
                await generatedTimeline.then(() => true)
                await new Promise(resolve => setTimeout(resolve, 10)); // Wait for 10 milliseconds
            }, Promise.resolve());
        }
        updateTimelineInput()
    });

    const deleteButton = document.querySelector('#delete-button');
    deleteButton?.addEventListener('click', async () => {
        const numberInput = <HTMLInputElement>document.querySelector('#number-input')

        // Make sure that the right animation duration is used
        setAnimationToggle()

        if (numberInput?.value) {
            const numbers = numberInput.value.split(',').map(Number);
            await numbers.reduce(async (previousPromise, num) => {
                await previousPromise;
                await algoVisualizer.undoableDelete(num);
                await new Promise(resolve => setTimeout(resolve, 10)); // Wait for 10 milliseconds
            }, Promise.resolve());
        }
        updateTimelineInput()
    });

    const playButton = document.querySelector('#play-button')
    playButton?.addEventListener('click', () => {
        const currentlyAnimationTimeline = algoVisualizer.currentAnimation
        if (currentlyAnimationTimeline) {
            currentlyAnimationTimeline.play()
        } else {
            console.log('no animation to play')
        }
    })

    const backButton = document.querySelector('#back-button')
    backButton?.addEventListener('click', () => {
        console.debug("pressed back button")
        algoVisualizer.algoStepHistory.stepBackwards()
    })

    const forwardButton = document.querySelector('#forward-button')
    forwardButton?.addEventListener('click', () => {
        console.debug("pressed forward button")
        algoVisualizer.algoStepHistory.stepForwards()
    })

    // seek listener
    const timelineInput = <HTMLInputElement>document.querySelector('#timeline-input')
    timelineInput?.addEventListener('input', () => {
        // console.debug('input event fired')
        const currentlyAnimationTimeline = algoVisualizer.currentAnimation
        if (currentlyAnimationTimeline) {
            currentlyAnimationTimeline.seek(timelineInput.valueAsNumber * currentlyAnimationTimeline.duration)
            // console.debug(timelineInput.valueAsNumber * currentlyAnimationTimeline.duration)
        }
    })

    // TODO refine this behavior. ex. make is so deselecting a checkbox doesn't start animation
    // again for example when the animation already finished.
    // Speed checkboxes listener
    checkboxes.forEach((checkbox) => {
        checkbox.addEventListener('mousedown', function (this: HTMLInputElement) {
            const currentAnimeProgress = algoVisualizer.currentAnimation.progress
            // If the checkbox button is already checked
            if (this.checked == false) {
                // Make the checkboxes mutually exclusive
                checkboxes.forEach((checkbox) => {
                    checkbox.checked = false;
                })
                speedModifier = Number(this.value)
                // Make it so that when a new speed modifier is selected and an animation is
                // currently playing the animation speeds up at the current location in the animation.
                // So that it looks seamless to the user.
                algoVisualizer.currentAnimation.stretch(currentAnimationOriginalDuration / speedModifier)
                // if we don't restart here there is one frame where the animation appears to be at a
                // different location than it should be. I don't know why this is.
                algoVisualizer.currentAnimation.restart()
                if (currentAnimeProgress == 1) {
                    // for some reason setting progress to 1 doesn't seem to 
                    // do anything. Therefore in order for the animation to
                    // appear as though it is at the end we set the progress
                    // to 0.99999. A number very close to 1
                    algoVisualizer.currentAnimation.progress = 0.99999
                } else {
                    algoVisualizer.currentAnimation.progress = currentAnimeProgress
                }
            } else {
                speedModifier = 1
                algoVisualizer.currentAnimation.stretch(currentAnimationOriginalDuration)
                // see comments above for clarification on this line
                algoVisualizer.currentAnimation.restart()
                if (currentAnimeProgress == 1) {
                    // see comments above for clarification on this line
                    algoVisualizer.currentAnimation.progress = 0.99999
                } else {
                    algoVisualizer.currentAnimation.progress = currentAnimeProgress
                }
            }
        });
    });

    animationToggle?.addEventListener('input', setAnimationToggle)


    /**
     *
     * Manipulates the range input dom element for controlling animations so
     * that the current animejs animation can be controlled correctly. Should be
     * called every time that the currentAnimation global is reassigned.
     * @returns 1 if successful and 0 if not
     */
    const updateTimelineInput = () => {
        console.debug('update timeline input')

        // TODO find solution for the fact that the children attribute is not
        // apart of the type.
        //timelineInput?.setAttribute('max', String(currentAnimation?.children.length))
        return 1
    }
}